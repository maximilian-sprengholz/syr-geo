file = file,
sep = ";",
row.names = FALSE,
col.names = colnames,
append = append
)
print(paste0("Written to ", file, ":"))
print(log)
}
# define output units and corresponding files
yf <- data.frame(unit = 1995:2022)
yf$input <- paste0(
data, "/external/temp/DWD/temp/temp_", yf$unit, "_grid.nc"
)
yf$unit <- "all"
# specify aggregation functions: with reference to variable names stacked in sds
aggfuns <- list(
mean = list(mean, "mean"),
min = list(min, "min"),
max = list(max, "max"),
d_low = list(
function(x, na.rm = FALSE) { sum(x < -10, na.rm = na.rm) }, # selbstdefiniert: < -10 Grad,
"min"
),
d_high1 = list(
function(x, na.rm = FALSE) { sum(x > 32, na.rm = na.rm) }, # DWD starke Wärmebelastung
"max"
),
d_high2 = list(
function(x, na.rm = FALSE) { sum(x > 38, na.rm = na.rm) }, # DWD extreme Wärmebelastung
"max"
)
)
# call processing function
log <- srproc(
yf,
aggfuns = aggfuns,
aggby = "yearmonth",
path = paste0(data, "/external/processed/DWD/temp"),
stub = "temp_hist",
extract = list(postcode = p_postcode),
cores = 3
)
# aggregation function:
# 1. reads in a raster file
# 2. aggregates using passed vector of c(aggfunction, subset)
# 3. aggregates by passed index (either integer or one of the predefined time values, e.g. "month")
sragg <- function (file, aggfun, aggby, forcetime, period, cores) {
# read
r <- terra::rast(file)
# force time format and zone; limiting to length(time(r)) ensures [start, end[ if output steps
# more detailed than input time (e.g. ymd_h instead of ymd, and last datetime is then ymd 23:00)
if (!is.null(forcetime)) {
# datetime conversion
if (!is.null(forcetime$step) && forcetime$step %in% c("years", "months", "days")) {
message("OK")
terra::time(r) <- as.Date(terra::time(r), tz = forcetime$timezone)
if (!is.null(forcetime$period)) {
forcetime$period$start <- as.Date(forcetime$period$start, tz = forcetime$timezone)
forcetime$period$end <- as.Date(forcetime$period$end, tz = forcetime$timezone)
}
} else {
terra::time(r) <- as.POSIXct(terra::time(r), tz = forcetime$timezone)
if (!is.null(forcetime$period)) {
forcetime$period$start <- as.POSIXct(forcetime$period$start, tz = forcetime$timezone)
forcetime$period$end <- as.POSIXct(forcetime$period$end, tz = forcetime$timezone)
}
}
# force time steps
if (!is.null(forcetime$step)) {
terra::time(r) <- seq(
from = terra::time(r)[1],
to = terra::time(r)[length(terra::time(r))] + 1,
by = forcetime$step
)[1:length(terra::time(r))]
}
}
# aggregation related checks and subsetting (rolling agg. extends period by 'window' ext(lo, hi))
ext <- c(0, 0)
if (!is.null(aggfun)) {
# allow direct passing of functions
if (typeof(aggfun) %in% c("closure", "builtin")) aggfun <- list(aggfun)
stopifnot(is.function(aggfun[[1]]))
# subset by aggregation layer if requested
# only relevant for files which have been pre-aggregated (e.g. 10min -> days -> months)
# and the 'days' file contains already, e.g., min/max values, which become monthly min/max
if (length(aggfun) > 1) {
stopifnot(length(aggfun) == 2)
stopifnot(aggfun[[2]] %in% varnames(r))
r <- r[aggfun[[2]]]
}
# estimate values for rolling 'window' needed for aggregation used in subsequent subsetting
if (!is.null(period) & length(aggby) == 2) {
if (aggby[[1]] == "to") ext <- c(aggby[[2]]-1, 0)
if (aggby[[1]] == "around") ext <- c(ceiling((aggby[[2]]-1)/2), floor((aggby[[2]]-1)/2))
if (aggby[[1]] == "from") ext <- c(0, aggby[[2]]-1)
}
}
# subset by period
if (!is.null(forcetime$period)) {
r <- r[[terra::time(r) >= forcetime$period$start - ext[[1]] & terra::time(r) <= forcetime$period$end + ext[[2]]]]
message(time(r))
}
# aggregate
if (!is.null(aggfun)) {
if (is.null(aggby)) {
# per cell
r <- terra::app(r, aggfun[[1]], na.rm = FALSE, cores = cores)
} else if (length(aggby) == 1) {
# per cell x time (e.g. month)
r <- terra::tapp(r, aggby, aggfun[[1]], na.rm = FALSE, cores = cores)
} else {
# per cell x moving n time units, e.g. 14 days up to certain date
time <- terra::time(r)
r <- terra::roll(r, aggby[[2]], aggfun[[1]], aggby[[1]], na.rm = FALSE)
terra::time(r) <- time # timestamps are lost when using custom functions...
# trim rolling overhangs from period kept for aggregation
if (!is.null(forcetime$period)) {
r <- r[[terra::time(r) >= forcetime$period$start & terra::time(r) <= forcetime$period$end]]
}
}
}
# return
return(r)
}
# define output units and corresponding files
yf <- data.frame(unit = "all")
yf$input <- paste0(data, "/external/raw/DWD/pr_sum_daily/pr_hyras_1_2022_v5-0_de.nc")
# specify aggregation functions
aggfuns <- list(
mean = mean,
min = min,
max = max,
d_low = function(x, na.rm = FALSE) { sum(x < 0.1, na.rm = na.rm) }, # no rain,
d_high1 = function(x, na.rm = FALSE) { sum(x >= 50, na.rm = na.rm) }, # DWD Ergbiebiger Dauerregen
d_high2 = function(x, na.rm = FALSE) { sum(x > 80, na.rm = na.rm) } # DWD extrem ergbiebiger Dauerregen
)
# call processing function
log <- srproc(
yf,
aggfuns = aggfuns,
aggby = list("to", 14),
forcetime = list(
step = "days",
timezone = "CET",
period = list(start = "2022-10-28", end = "2022-12-09")
),
#path = paste0(data, "/external/processed/DWD/pr"),
stub = "pr_presurvey",
extract = list(postcode = p_postcode),
timelong = TRUE
)
# aggregation function:
# 1. reads in a raster file
# 2. aggregates using passed vector of c(aggfunction, subset)
# 3. aggregates by passed index (either integer or one of the predefined time values, e.g. "month")
sragg <- function (file, aggfun, aggby, forcetime, period, cores) {
# read
r <- terra::rast(file)
# force time format and zone; limiting to length(time(r)) ensures [start, end[ if output steps
# more detailed than input time (e.g. ymd_h instead of ymd, and last datetime is then ymd 23:00)
if (!is.null(forcetime)) {
# datetime conversion
if (!is.null(forcetime$step) && forcetime$step %in% c("years", "months", "days")) {
terra::time(r) <- as.Date(terra::time(r), tz = forcetime$timezone)
if (!is.null(forcetime$period)) {
forcetime$period$start <- as.Date(forcetime$period$start, tz = forcetime$timezone)
forcetime$period$end <- as.Date(forcetime$period$end, tz = forcetime$timezone)
}
} else {
terra::time(r) <- as.POSIXct(terra::time(r), tz = forcetime$timezone)
if (!is.null(forcetime$period)) {
forcetime$period$start <- as.POSIXct(forcetime$period$start, tz = forcetime$timezone)
forcetime$period$end <- as.POSIXct(forcetime$period$end, tz = forcetime$timezone)
}
}
# force time steps
if (!is.null(forcetime$step)) {
terra::time(r) <- seq(
from = terra::time(r)[1],
to = terra::time(r)[length(terra::time(r))] + 1,
by = forcetime$step
)[1:length(terra::time(r))]
}
}
# aggregation related checks and subsetting (rolling agg. extends period by 'window' ext(lo, hi))
ext <- c(0, 0)
if (!is.null(aggfun)) {
# allow direct passing of functions
if (typeof(aggfun) %in% c("closure", "builtin")) aggfun <- list(aggfun)
stopifnot(is.function(aggfun[[1]]))
# subset by aggregation layer if requested
# only relevant for files which have been pre-aggregated (e.g. 10min -> days -> months)
# and the 'days' file contains already, e.g., min/max values, which become monthly min/max
if (length(aggfun) > 1) {
stopifnot(length(aggfun) == 2)
stopifnot(aggfun[[2]] %in% varnames(r))
r <- r[aggfun[[2]]]
}
# estimate values for rolling 'window' needed for aggregation used in subsequent subsetting
if (!is.null(period) & length(aggby) == 2) {
if (aggby[[1]] == "to") ext <- c(aggby[[2]]-1, 0)
if (aggby[[1]] == "around") ext <- c(ceiling((aggby[[2]]-1)/2), floor((aggby[[2]]-1)/2))
if (aggby[[1]] == "from") ext <- c(0, aggby[[2]]-1)
}
}
# subset by period
if (!is.null(forcetime$period)) {
r <- r[[terra::time(r) >= forcetime$period$start - ext[[1]] & terra::time(r) <= forcetime$period$end + ext[[2]]]]
}
# aggregate
if (!is.null(aggfun)) {
if (is.null(aggby)) {
# per cell
r <- terra::app(r, aggfun[[1]], na.rm = FALSE, cores = cores)
} else if (length(aggby) == 1) {
# per cell x time (e.g. month)
r <- terra::tapp(r, aggby, aggfun[[1]], na.rm = FALSE, cores = cores)
} else {
# per cell x moving n time units, e.g. 14 days up to certain date
time <- terra::time(r)
r <- terra::roll(r, aggby[[2]], aggfun[[1]], aggby[[1]], na.rm = FALSE)
terra::time(r) <- time # timestamps are lost when using custom functions...
# trim rolling overhangs from period kept for aggregation
if (!is.null(forcetime$period)) {
r <- r[[terra::time(r) >= forcetime$period$start & terra::time(r) <= forcetime$period$end]]
}
}
}
# return
return(r)
}
# define output units and corresponding files
yf <- data.frame(unit = "all")
yf$input <- paste0(data, "/external/raw/DWD/pr_sum_daily/pr_hyras_1_2022_v5-0_de.nc")
# specify aggregation functions
aggfuns <- list(
mean = mean,
min = min,
max = max,
d_low = function(x, na.rm = FALSE) { sum(x < 0.1, na.rm = na.rm) }, # no rain,
d_high1 = function(x, na.rm = FALSE) { sum(x >= 50, na.rm = na.rm) }, # DWD Ergbiebiger Dauerregen
d_high2 = function(x, na.rm = FALSE) { sum(x > 80, na.rm = na.rm) } # DWD extrem ergbiebiger Dauerregen
)
# call processing function
log <- srproc(
yf,
aggfuns = aggfuns,
aggby = list("to", 14),
forcetime = list(
step = "days",
timezone = "CET",
period = list(start = "2022-10-28", end = "2022-12-09")
),
path = paste0(data, "/external/processed/DWD/pr"),
stub = "pr_presurvey",
extract = list(postcode = p_postcode),
timelong = TRUE
)
crs <- "PROJCS[\"Radolan projection\",
GEOGCS[\"Radolan Coordinate System\",
DATUM[\"Radolan Kugel\",
SPHEROID[\"Erdkugel\",6370040.0,0.0,
LENGTHUNIT[\"metre\",1]]],
PRIMEM[\"Greenwich\",0,
ANGLEUNIT[\"Degree\",0.017453292519943295]]],
CONVERSION[\"North_Pole_Stereographic\",
METHOD[\"Polar Stereographic (variant A)\",
ID[\"EPSG\",9810]],
PARAMETER[\"Latitude of natural origin\",90,
ANGLEUNIT[\"Degree\",0.017453292519943295],
ID[\"EPSG\",8801]],
PARAMETER[\"Longitude of natural origin\",10,
ANGLEUNIT[\"Degree\",0.017453292519943295],
ID[\"EPSG\",8802]],
PARAMETER[\"Scale factor at natural origin\",1,
SCALEUNIT[\"unity\",0.9330127019],
ID[\"EPSG\",8805]],
PARAMETER[\"False easting\",0,
LENGTHUNIT[\"metre\",1],
ID[\"EPSG\",8806]],
PARAMETER[\"False northing\",0,
LENGTHUNIT[\"metre\",1],
ID[\"EPSG\",8807]]],
PARAMETER[\"Latitude of standard parallel\",60,
ANGLEUNIT[\"Degree\",0.017453292519943295],
ID[\"EPSG\",8832]],
CS[Cartesian,2],
AXIS[\"(E)\",south,
ANGLEUNIT[\"degree\",0.017453292519943295],
ORDER[1],
LENGTHUNIT[\"metre\",1]],
AXIS[\"(N)\",south,
MERIDIAN[180,
ANGLEUNIT[\"degree\",0.017453292519943295]],
ORDER[2],
LENGTHUNIT[\"metre\",1]]
]"
r <- rast("C:/Users/max/Seafile/FoDiRa-SYR/survey/data/external/raw/DWD/pr_sum_5min/2022/YW_2017.002_20220101.nc")
crs(r) <- crs
crs
terra::crs(r) <- crs
crs <- "PROJCS[\"Radolan projection\",
GEOGCS[\"Radolan Coordinate System\",
DATUM[\"Radolan Kugel\",
SPHEROID[\"Erdkugel\",6370040.0,0.0,
LENGTHUNIT[\"metre\",1]]],
PRIMEM[\"Greenwich\",0,
ANGLEUNIT[\"Degree\",0.017453292519943295]]],
CONVERSION[\"North_Pole_Stereographic\",
METHOD[\"Polar Stereographic (variant A)\",
ID[\"EPSG\",9810]],
PARAMETER[\"Latitude of natural origin\",90,
ANGLEUNIT[\"Degree\",0.017453292519943295],
ID[\"EPSG\",8801]],
PARAMETER[\"Longitude of natural origin\",10,
ANGLEUNIT[\"Degree\",0.017453292519943295],
ID[\"EPSG\",8802]],
PARAMETER[\"Scale factor at natural origin\",1,
SCALEUNIT[\"unity\",0.9330127019],
ID[\"EPSG\",8805]],
PARAMETER[\"False easting\",0,
LENGTHUNIT[\"metre\",1],
ID[\"EPSG\",8806]],
PARAMETER[\"False northing\",0,
LENGTHUNIT[\"metre\",1],
ID[\"EPSG\",8807]]],
PARAMETER[\"Latitude of standard parallel\",60,
ANGLEUNIT[\"Degree\",0.017453292519943295],
ID[\"EPSG\",8832]],
CS[Cartesian,2],
AXIS[\"(E)\",south,
ANGLEUNIT[\"degree\",0.017453292519943295],
ORDER[1],
LENGTHUNIT[\"metre\",1]],
AXIS[\"(N)\",south,
MERIDIAN[180,
ANGLEUNIT[\"degree\",0.017453292519943295]],
ORDER[2],
LENGTHUNIT[\"metre\",1]]
UNIT[\"metre\",1,
AUTHORITY[\"EPSG\",\"9001\"]],
]"
terra::crs(r) <- crs
crs <- "PROJCS[\"Radolan projection\",
GEOGCS[\"Radolan Coordinate System\",
DATUM[\"Radolan Kugel\",
SPHEROID[\"Erdkugel\",6370040.0,0.0,
LENGTHUNIT[\"metre\",1]]],
PRIMEM[\"Greenwich\",0,
ANGLEUNIT[\"Degree\",0.017453292519943295]]],
CONVERSION[\"North_Pole_Stereographic\",
METHOD[\"Polar Stereographic (variant A)\",
ID[\"EPSG\",9810]],
PARAMETER[\"Latitude of natural origin\",90,
ANGLEUNIT[\"Degree\",0.017453292519943295],
ID[\"EPSG\",8801]],
PARAMETER[\"Longitude of natural origin\",10,
ANGLEUNIT[\"Degree\",0.017453292519943295],
ID[\"EPSG\",8802]],
PARAMETER[\"Scale factor at natural origin\",1,
SCALEUNIT[\"unity\",0.9330127019],
ID[\"EPSG\",8805]],
PARAMETER[\"False easting\",0,
LENGTHUNIT[\"metre\",1],
ID[\"EPSG\",8806]],
PARAMETER[\"False northing\",0,
LENGTHUNIT[\"metre\",1],
ID[\"EPSG\",8807]]],
PARAMETER[\"Latitude of standard parallel\",60,
ANGLEUNIT[\"Degree\",0.017453292519943295],
ID[\"EPSG\",8832]],
CS[Cartesian,2],
AXIS[\"(E)\",south,
ANGLEUNIT[\"degree\",0.017453292519943295],
ORDER[1],
LENGTHUNIT[\"metre\",1]],
AXIS[\"(N)\",south,
MERIDIAN[180,
ANGLEUNIT[\"degree\",0.017453292519943295]],
ORDER[2],
LENGTHUNIT[\"metre\",1]],
UNIT[\"metre\",1,
AUTHORITY[\"EPSG\",\"9001\"]],
]"
terra::crs(r) <- crs
crs2 <- "PROJCS[\"North_Pole_Stereographic\",
GEOGCS[\"WGS 84\",
DATUM[\"WGS_1984\",
SPHEROID[\"WGS 84\",6378137,298.257223563,
AUTHORITY[\"EPSG\",\"7030\"]],
AUTHORITY[\"EPSG\",\"6326\"]],
PRIMEM[\"Greenwich\",0],
UNIT[\"Degree\",0.0174532925199433]],
PROJECTION[\"Polar_Stereographic\"],
PARAMETER[\"latitude_of_origin\",90],
PARAMETER[\"central_meridian\",0],
PARAMETER[\"scale_factor\",1],
PARAMETER[\"false_easting\",0],
PARAMETER[\"false_northing\",0],
UNIT[\"metre\",1,
AUTHORITY[\"EPSG\",\"9001\"]],
AUTHORITY[\"ESRI\",\"102018\"]]
"
terra::crs(r) <- crs2
#
# This file processes various DWD geo-referenced data:
# - historical precipitation and temperature
# - pr/temp over 14 days up to (includign survey date)
# - pr/temp at time of interview
#
### config (relative to working dir syr-geo!)
rm(list = ls())
source("src/_config.R")
#
# This file processes various DWD geo-referenced data:
# - historical precipitation and temperature
# - pr/temp over 14 days up to (includign survey date)
# - pr/temp at time of interview
#
### config (relative to working dir syr-geo!)
rm(list = ls())
# get user = username on machine
user = Sys.info()[7]
# paths
paths = list(
max = list(
wd = "C:/Users/max/Seafile/syr-geo",
data = "C:/Users/max/Seafile/FoDiRa-SYR/survey/data"
)
)
for (key in names(paths[[user]])) {
do.call("<-", list(key, unlist(paths[[user]][key])))
}
### packages
library(tibble)
library(dplyr)
library(tidyr)
if (!require(sjlabelled)) install.packages("sjlabelled")
library(sjlabelled)
if (!require(lubridate)) install.packages("lubridate")
library(lubridate)
if (!require(zoo)) install.packages("zoo")
library(zoo)
if (!require(sf)) install.packages("sf")
library(sf)
if (!require(terra)) install.packages("terra")
library(terra)
terra::gdalCache(8000) # 8 GB per chunk
terraOptions(todisk = TRUE)
terraOptions(steps = 6)
if (!require(ncdf4)) install.packages("ncdf4")
library(ncdf4) # necessary for writing .nc
if (!require(pbapply)) install.packages("pbapply")
library(pbapply)
if (!require(exactextractr)) install.packages("exactextractr")
library(exactextractr)
### Shapefiles PLZ (info from 31.12.2021, accessed Feb 28, 2023; last updated Feb 2022)
# https://downloads.suche-postleitzahl.org/v2/public/plz-5stellig.shp.zip
p_postcode <- vect(paste0(data, "/external/raw/Shapefiles/plz/plz-5stellig.shp"))
p_postcode <- p_postcode[c("plz")]
names(p_postcode) <- c("postcode")
terra::gdal()
#
# This file processes various DWD geo-referenced data:
# - historical precipitation and temperature
# - pr/temp over 14 days up to (includign survey date)
# - pr/temp at time of interview
#
### config (relative to working dir syr-geo!)
rm(list = ls())
# get user = username on machine
user = Sys.info()[7]
# paths
paths = list(
max = list(
wd = "C:/Users/max/Seafile/syr-geo",
data = "C:/Users/max/Seafile/FoDiRa-SYR/survey/data"
)
)
for (key in names(paths[[user]])) {
do.call("<-", list(key, unlist(paths[[user]][key])))
}
### packages
library(tibble)
library(dplyr)
library(tidyr)
if (!require(sjlabelled)) install.packages("sjlabelled")
library(sjlabelled)
if (!require(lubridate)) install.packages("lubridate")
library(lubridate)
if (!require(zoo)) install.packages("zoo")
library(zoo)
if (!require(sf)) install.packages("sf")
library(sf)
if (!require(terra)) install.packages("terra")
library(terra)
terra::gdalCache(8000) # 8 GB per chunk
terraOptions(todisk = TRUE)
terraOptions(steps = 6)
if (!require(ncdf4)) install.packages("ncdf4")
library(ncdf4) # necessary for writing .nc
if (!require(pbapply)) install.packages("pbapply")
library(pbapply)
if (!require(exactextractr)) install.packages("exactextractr")
library(exactextractr)
### Shapefiles PLZ (info from 31.12.2021, accessed Feb 28, 2023; last updated Feb 2022)
# https://downloads.suche-postleitzahl.org/v2/public/plz-5stellig.shp.zip
p_postcode <- vect(paste0(data, "/external/raw/Shapefiles/plz/plz-5stellig.shp"))
p_postcode <- p_postcode[c("plz")]
names(p_postcode) <- c("postcode")
terra::gdal()
